" ##############################################################################
" ################################  Vim options  ###############################
" ##############################################################################

set backspace=indent,eol,start
set diffopt+=vertical
set expandtab
set exrc
set foldcolumn=1
set foldmethod=manual
set formatoptions=cq
set hidden
set hlsearch
set ignorecase
set smartcase
set langmap=ЙQ,ЦW,УE,КR,ЕT,НY,ГU,ШI,ЩO,ЗP,Х[,Ъ],ФA,ЫS,ВD,АF,ПG,РH,ОJ,ЛK,ДL,Ж\\;,Э',ЯZ,ЧX,СC,МV,ИB,ТN,ЬM,Б\\,,Ю.,йq,цw,уe,кr,еt,нy,гu,шi,щo,зp,х[,ъ],фa,ыs,вd,аf,пg,рh,оj,лk,дl,ж\\;,э',яz,чx,сc,мv,иb,тn,ьm,б\\,,ю.,"@,№#,;$,:^,?&
set lazyredraw
set noautoindent
set nocompatible
set noesckeys
set nosmartindent
set number
set relativenumber
set ruler
set runtimepath+=~/.vim/bundle/Vundle.vim/
set secure
set shiftwidth=4
set showcmd
set softtabstop=4
set splitright
set t_ut=
set tabstop=4
set ttimeoutlen=50
set wildmenu

highlight ExtraWhitespace ctermbg=darkgreen
highlight Terminal guifg=#c0c0c0 guibg=#000040 ctermfg=gray ctermbg=black
match ExtraWhitespace /\s\+$/
syntax enable

" ##############################################################################
" ##############################  Plugin settings  #############################
" ##############################################################################

" C++11 syntax workaround
let c_no_curly_error=1

" Netrw settings
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro'
let g:netrw_keepdir = 0
let g:netrw_list_hide = ".*.swp"
let g:netrw_preview = 1 " Vertical preview window

" YouCompleteMe settings
let g:ycm_always_populate_location_list = 1
let g:ycm_confirm_extra_conf = 0
let g:ycm_global_ycm_extra_conf = expand('~/git/ovandriyanov/util/kernel_ycm_extra_conf.py')
" let g:ycm_autoclose_preview_window_after_insertion = 1

" AutoPairs settings
let g:AutoPairsMapCR = 0
let g:AutoPairsMultilineClose = 0
let g:AutoPairsShortcutFastWrap = '<C-e>'
let g:AutoPairsShortcutJump = '<C-n>'
let g:AutoPairsShortcutToggle = '<C-p>'

" My settings
let g:olan_path_aliases_file = expand('~/.vim/path_aliases')

" ##############################################################################
" ##############################  Custom commands  #############################
" ##############################################################################

command! Vrc exe 'edit' resolve(expand('~/.vimrc'))
command! TVrc tabnew | exe 'edit' resolve(expand('~/.vimrc'))
command! VVrc vsplit | exe 'edit' resolve(expand('~/.vimrc'))
command! SVrc split | exe 'edit' resolve(expand('~/.vimrc'))
command! Ve Vexplore!
command! E Explore
command! StripTrailingWhitespace %s/\s\+$//e
command! -count=1 PadDown call Pad(<count>)
command! -count=1 PadUp call Pad(-<count>)
command! -bang DHidden call DeleteHiddenBuffers('<bang>')
command! -nargs=1 Yank call Yank('<args>')
command! -nargs=1 -complete=customlist,CompleteFileAliases C call OpenFileByAlias('<args>', '')
command! -nargs=1 -complete=customlist,CompleteFileAliases Sc call OpenFileByAlias('<args>', 'split')
command! -nargs=1 -complete=customlist,CompleteFileAliases Vc call OpenFileByAlias('<args>', 'vsplit')
command! -nargs=1 -complete=customlist,CompleteFileAliases Tc call OpenFileByAlias('<args>', 'tabnew')
command! TTerminal tabnew | terminal ++curwin
command! VTerminal vertical terminal
command! STerminal terminal
command! CTerminal terminal ++curwin
command! MTerminal split | resize 10 | set winfixheight | terminal ++curwin
command! -bang -range -nargs=1 Xargs call Xargs('<args>', '<bang>' == '!')

" ##############################################################################
" ##############################  Custom mappings  #############################
" ##############################################################################

" Screen escape sequences workaround
noremap             <Esc>[1~        <Home>
noremap             <Esc>[4~        <End>
tnoremap            <Esc>[1~        <Home>
tnoremap            <Esc>[4~        <End>
inoremap            <Esc>OM         <Cr>

" QtCreator-like bindings
nnoremap            <F2>            :YcmCompleter GoTo <cr>
nnoremap            <F4>            :silent! A <cr>
nnoremap            <F6>            :vsplit <cr>:YcmCompleter GoTo <cr>
nnoremap            <F8>            :silent! AV <cr>
nnoremap            <C-k>           :CommandT <cr>

" Visual mode search
vnoremap            *               <esc>/\V<c-r>=escape(getreg('*'), '/')<cr><cr>
vnoremap            #               <esc>`<?\V<c-r>=escape(getreg('*'), '/')<cr><cr>
vnoremap            <Leader>*       <esc>/\V\<<c-r>=escape(getreg('*'), '/')<cr>\><cr>
vnoremap            <leader>#       <esc>`<?\V\<<c-r>=escape(getreg('*'), '/')<cr>\><cr>

" Command line register escaping
cnoremap            <c-r>\"         <c-r>=escape(getreg('"'), '/')<cr>
cnoremap            <c-r>\+         <c-r>=escape(getreg('+'), '/')<cr>

" Padding
nnoremap            <silent>        <Plug>PadDown :<c-U>call Pad(v:count1)<cr>:call repeat#set("\<Plug>PadDown")<cr>
nnoremap            <silent>        <Plug>PadUp :<c-U>call Pad(-v:count1)<cr>:call repeat#set("\<Plug>PadUp")<cr>
nnoremap            <C-p>j          <Plug>PadDown
nnoremap            <C-p>k          <Plug>PadUp
nnoremap            <silent>        <Plug>BreakAndPadComma :<c-U>call BreakAndPad(',', v:count1)<cr>:call repeat#set("\<Plug>BreakAndPadComma")<cr>
nnoremap            <C-p>,          <Plug>BreakAndPadComma

" Error navigation
nnoremap            <down>          :cn<cr>
nnoremap            <up>            :cp<cr>

" Buffer switching
nnoremap            <C-Right>       :bn<cr>
nnoremap            <C-Left>        :bp<cr>
nnoremap            <C-w><Right>    :bn<cr>
nnoremap            <C-w><Left>     :bp<cr>
tnoremap            <c-w><C-Right>  <c-w>:bn<cr>
tnoremap            <c-w><C-Left>   <c-w>:bp<cr>

" File navigation
nnoremap            <c-w>f          :call FindFileReuseWindow(0)<cr>
" TODO: implement
nnoremap            <c-w>F          :vertical wincmd F<cr>

vnoremap            <c-w>f          :call FindFileReuseWindow(1)<cr>
" TODO: implement
" vnoremap <c-w>F :<c-u>vertical wincmd F<cr>

" Tab navigation
nnoremap            <Left>          gT
nnoremap            <Right>         gt
nnoremap            <C-w><Left>     gT
nnoremap            <C-w><Right>    gt
tnoremap            <C-w><Left>     <C-w>gT
tnoremap            <C-w><Right>    <C-w>gt

" Jumping around
nnoremap            <C-F><C-O>      :call JumpToPrevFile()<Cr>
nnoremap            <C-F><C-I>      :call JumpToNextFile()<Cr>

" Inserting
inoremap <expr> <CR> MapCarriageReturn()

" Should probably get rid of these...
nnoremap <F5>       :highlight ExtraWhitespace ctermbg=darkgreen <CR>
nnoremap <S-F5>     :highlight ExtraWhitespace NONE <CR>

" ##############################################################################
" ############################  Automatic commands  ############################
" ##############################################################################

augroup vimrc
    " Clear all autocommands within augroup 'vimrc'
    autocmd!

    " Do not clear clipboard on exit
    autocmd VimLeave *                  call system("xsel -ib", getreg('+'))

    " Highlight extra whitespace
    autocmd WinNew *                    highlight ExtraWhitespace ctermbg=darkgreen
    autocmd WinNew *                    match ExtraWhitespace /\s\+$/

    " Set libstdc++ source files options
    autocmd BufRead,BufNewFile /usr/include/c++/*,/usr/include/x86_64-linux-gnu/c++/*,/usr/include/linux/* call SetLibStdCppOptions()

    autocmd BufReadPost /* if &buftype == '' | lcd %:h | endif
augroup END

" ##############################################################################
" ##############################  Custom functions  ############################
" ##############################################################################

function! SetLibStdCppOptions()
    setlocal ft=cpp
    setlocal tabstop=8
endfunction

function! Pad(count)
    let l:x = a:count
    " sleep 1
    let l:pad_to = col('.')
    while l:x != 0
        if l:x > 0
            exe 'normal j^'
            let l:x = l:x - 1
        elseif l:x < 0
            exe 'normal k^'
            let l:x = l:x + 1
        endif

        let l:pad_from = col('.')
        let l:diff = abs(l:pad_to - l:pad_from)
        if l:pad_from < l:pad_to
            exe 'normal ' . l:diff . 'i '
        elseif l:diff > 0
            exe 'normal ' . l:diff . 'X'
        endif
        call cursor(line('.'), l:pad_to)
    endwhile
endfunction

function! GetCurrentChar()
    return matchstr(getline('.'), '\%' . col('.') . 'c.')
endfunction

function! BreakAndPad(char, count)
    let l:i = 0
    while l:i < a:count
        let l:line = line('.')
        let l:col = col('.')
        exe 'normal f' . a:char
        if GetCurrentChar() != a:char
            return
        endif
        exe "normal a\n"
        call cursor(l:line, l:col)
        call Pad(1)
        let l:i = l:i + 1
    endwhile
endfunction

function! DeleteHiddenBuffers(bang)
    let tpbl=[]
    call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
    for buf in filter(range(1, bufnr('$')), 'bufloaded(v:val) && index(tpbl, v:val)==-1')
        silent execute 'silent bdelete' . a:bang buf
    endfor
endfunction

function! Yank(args)
    if len(a:args) > 1 && a:args[1] == ' '
        let l:reg = a:args[0]
        let l:yanktext = a:args[2 + match(a:args[2:], '[^ ]'):]
    else
        let l:reg = '"'
        let l:yanktext = a:args
    endif
    exe 'let @' . l:reg . ' = "' . escape(expand(l:yanktext), '"') . '"'
endfunction

function! IsTerminalWindow(winnr)
    let l:bufnr = winbufnr(a:winnr)
    let l:buftype = getbufvar(l:bufnr, '&buftype')
    return l:buftype == 'terminal'
endfunction

function! OpenOrReuseWindow()
    " TODO: netrw windows not handled very well
    let l:curwin = winnr()
    let l:curtab = tabpagenr()
    let l:wincnt = tabpagewinnr(l:curtab, '$')
    let l:termcnt = 0

    for l:wnum in range(1, l:wincnt)
        if IsTerminalWindow(l:wnum)
            let l:termcnt += 1
        endif
    endfor

    let l:reusable = l:wincnt
    let l:reusable -= l:termcnt
    let l:reusable -= IsTerminalWindow(l:curwin) ? 0 : 1

    if l:reusable == 0
        exe 'vsplit'
        let l:newwin = winnr()
        call win_gotoid(win_getid(l:curwin))
        return l:newwin
    endif

    for l:wnum in range(1, l:wincnt)
        if l:wnum != l:curwin && !IsTerminalWindow(l:wnum)
            return l:wnum
        endif
    endfor
endfunction

function! FindFileReuseWindow(visual)
    if a:visual
        let l:cfile = getreg('*')
    else
        let l:cfile = expand('<cfile>')
    endif

    let l:includeexpr = substitute(&l:includeexpr, 'v:fname', 'l:cfile', '')
    if len(l:includeexpr)
        execute 'let l:cfile = ' . l:includeexpr
    endif

    let l:searchpath = &l:path
    if empty(l:searchpath)
        let l:searchpath = &g:path
    endif
    let l:searchpath = '.,' . l:searchpath

    let l:path = findfile(l:cfile, l:searchpath)
    if empty(l:path)
        let l:path = finddir(l:cfile, l:searchpath)
        if empty(l:path)
            echomsg "Can't find file " . l:cfile . " in path"
            return
        endif
    endif
    echom 'Found file or dir: ' . l:path

    let l:oldwinnr = winnr()
    let l:newwinnr = OpenOrReuseWindow()
    if getcwd(l:oldwinnr) !=# getcwd(l:newwinnr)
        let l:path = fnamemodify(l:path, ':p')
    endif

    call win_gotoid(win_getid(l:newwinnr))
    exe 'edit' l:path
endfunction

function! JumpToPrevFile()
    let [l:jumps, l:curjump] = getjumplist()
    let l:jumps = l:jumps[:l:curjump]
    call reverse(l:jumps)

    let l:i = l:curjump == len(l:jumps)
    for l:j in l:jumps
        if l:j['bufnr'] != bufnr()
            execute 'normal' l:i . "\<C-O>"
            return
        endif
        let l:i += 1
    endfor
    echo 'Already at oldest file'
endfunction

function! JumpToNextFile()
    let [l:jumps, l:curjump] = getjumplist()
    let l:jumps = l:jumps[l:curjump:]

    let l:i = 0
    for l:j in l:jumps
        if l:j['bufnr'] != bufnr()
            for l:jj in l:jumps[l:i + 1:]
                if l:jj['bufnr'] != l:j['bufnr']
                    break
                endif
                let l:i += 1
            endfor

            execute 'normal' l:i . "\<C-I>"
            return
        endif
        let l:i += 1
    endfor
    echo 'Already at newest file'
endfunction

function! LoadPathAliases()
    try
        let l:aliases = {}
        for l:line in readfile(g:olan_path_aliases_file)
            let l:items = l:line->split()
            for l:alias in l:items[1:]
                let l:aliases[tolower(l:alias)] = {'path': l:items[0], 'name': l:items[1]}
            endfor
        endfor
        return l:aliases
    catch /Can't open file/
        return {}
    endtry
endfunction

function! OpenFileByAlias(alias, window_splitter)
    if !exists('g:olan_path_aliases')
        let g:olan_path_aliases = LoadPathAliases()
    endif

    let l:value = get(g:olan_path_aliases, tolower(a:alias))
    if type(l:value) == type(0) && !l:value
        echom 'Unknown alias: ' . a:alias
        return
    endif

    let l:path = expand(l:value['path'])

    if !isdirectory(l:path) && !filereadable(l:path)
        echom 'Cannot open ' . l:path
        return
    end

    if len(a:window_splitter) > 0
        execute a:window_splitter
    endif
    execute 'edit' l:path
endfunction

function! CompleteFileAliases(arglead, ...)
    if !exists('g:olan_path_aliases')
        let g:olan_path_aliases = LoadPathAliases()
    endif

    let l:candidates = {}
    let l:Chop = len(a:arglead) ? {str -> str[:len(a:arglead) - 1]} : {str -> ''}

    for [l:alias, l:value] in items(g:olan_path_aliases)
        if l:Chop(l:alias) ==? a:arglead
            let l:name = l:value['name']
            let l:oldalias = get(l:candidates, l:name, 0)
            if type(l:oldalias) == type(0) || l:alias < l:oldalias
                let l:candidates[l:name] = l:alias
            endif
        endif
    endfor

    return map(
    \   sort(
    \       items(l:candidates),
    \       {l, r -> l[1] < r[1] ? -1 : l[1] > r[1]}
    \   ),
    \   'v:val[0]'
    \)
endfunction

function! Xargs(args, substitute)
    let l:result = system('xargs --delimiter "\n" ' . a:args, getreg('*'))
    let l:exit_code = v:shell_error

    if l:exit_code != 0
        echoerr l:result
        return
    endif

    if a:substitute
        let l:rbound = l:result[-1:] == "\n" ? -2 : -1
        execute 'normal' "gv\"=l:result[:" . l:rbound . "]\<CR>p"
    endif
endfunction

function! Tapi_FillQuickfixWindow(buffer, logfile)
    execute 'cgetfile' a:logfile
    call system('rm -f ' . a:logfile)
endfunction

function! Tapi_Chdir(buffer, pwd)
    execute 'lcd' a:pwd
endfunction

function! MapCarriageReturn()
    let l:line = getline('.')
    let l:curcol = getpos('.')[2]
    let l:prevchar = l:line[l:curcol - 2]
    let l:curchar = l:line[l:curcol - 1]
    if l:prevchar != '{'
        return "\<CR>"
    endif
    let l:maybe_rbrace = l:curchar == '}' ? '' : '}'
    return "\<CR>" . l:maybe_rbrace . "\<C-O>O"
endfunction

" ##############################################################################
" ################################  Vundle stuff  ##############################
" ##############################################################################

filetype off
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'

Plugin 'jiangmiao/auto-pairs'
Plugin 'endel/vim-github-colorscheme'
Plugin 'google/vim-searchindex'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-surround'
Plugin 'vim-scripts/BufOnly.vim'

if exists('g:devmode') && g:devmode
    " C/C++ stuff
    Plugin 'vim-scripts/Cpp11-Syntax-Support'   " Proper C++11 syntax highlighting
    Plugin 'Valloric/YouCompleteMe'
    Plugin 'mom0tomo/dotfiles'
    Plugin 'wincent/command-t'
    Plugin 'vim-scripts/git-time-lapse'
    Plugin 'vim-scripts/a.vim'                  " Quick switching between .h/.cpp
    Plugin 'tpope/vim-fugitive'
    Plugin 'vim-vcscommand', {'pinned': 1}
    Plugin 'vim-signify', {'pinned': 1}
    " Plugin 'vim-quarc', {'pinned': 1}
endif

call vundle#end()
filetype plugin indent on

colorscheme github

" ##############################################################################
" ############################  Extra configuration  ###########################
" ##############################################################################

let s:extra_conf_file = expand('~/.vim/extra.vim')
if filereadable(s:extra_conf_file)
    exe "source " . s:extra_conf_file
endif
